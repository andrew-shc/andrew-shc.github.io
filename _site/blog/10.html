<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2026-02-15">

<title>Foggy Cornell Box</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-065a5179aebd64318d7ea99d77b64a9e.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-969ddfa49e00a70eb3423444dbc81f6c.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-065a5179aebd64318d7ea99d77b64a9e.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-443a8c2d8fa65f4c6b846c90aafe8287.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-30fc45633b0910a22497ea642fc28e10.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-443a8c2d8fa65f4c6b846c90aafe8287.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/live-runtime/live-runtime.js" type="module"></script>
<link href="../site_libs/quarto-contrib/live-runtime/live-runtime.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script type="module" src="../site_libs/quarto-ojs/quarto-ojs-runtime.js"></script>
<link href="../site_libs/quarto-ojs/quarto-ojs.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../math-styling.css">
</head>

<body class="floating slimcontent quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const queryPrefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    const darkModeDefault = queryPrefersDark.matches;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    queryPrefersDark.addEventListener("change", e => {
      if(window.localStorage.getItem("quarto-color-scheme") !== null)
        return;
      const alternate = e.matches
      toggleColorMode(alternate);
      localAlternateSentinel = e.matches ? 'alternate' : 'default'; // this is used alongside local storage!
      toggleGiscusIfUsed(alternate, darkModeDefault);
    });
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#volumetric-scattering-model" id="toc-volumetric-scattering-model" class="nav-link active" data-scroll-target="#volumetric-scattering-model">Volumetric Scattering Model</a>
  <ul class="collapse">
  <li><a href="#transmittance" id="toc-transmittance" class="nav-link" data-scroll-target="#transmittance">Transmittance</a></li>
  <li><a href="#the-equation-of-transfer" id="toc-the-equation-of-transfer" class="nav-link" data-scroll-target="#the-equation-of-transfer">The Equation of Transfer</a></li>
  </ul></li>
  <li><a href="#volumetric-light-transport" id="toc-volumetric-light-transport" class="nav-link" data-scroll-target="#volumetric-light-transport">Volumetric Light Transport</a>
  <ul class="collapse">
  <li><a href="#quick-tangent-variance-reduction-of-l_i" id="toc-quick-tangent-variance-reduction-of-l_i" class="nav-link" data-scroll-target="#quick-tangent-variance-reduction-of-l_i">Quick Tangent: Variance Reduction of <span class="math inline">\(L_i\)</span></a></li>
  <li><a href="#continuation-solving-recursion-with-operators" id="toc-continuation-solving-recursion-with-operators" class="nav-link" data-scroll-target="#continuation-solving-recursion-with-operators">Continuation: Solving recursion with operators</a></li>
  <li><a href="#evaluating-path-integrals" id="toc-evaluating-path-integrals" class="nav-link" data-scroll-target="#evaluating-path-integrals">Evaluating path integrals</a></li>
  </ul></li>
  <li><a href="#perfect-scattering-of-the-fog" id="toc-perfect-scattering-of-the-fog" class="nav-link" data-scroll-target="#perfect-scattering-of-the-fog">Perfect Scattering of the Fog</a>
  <ul class="collapse">
  <li><a href="#algorithmic-view-of-monte-carlo-estimation-of-volumetric-path-integrals" id="toc-algorithmic-view-of-monte-carlo-estimation-of-volumetric-path-integrals" class="nav-link" data-scroll-target="#algorithmic-view-of-monte-carlo-estimation-of-volumetric-path-integrals">Algorithmic View of Monte-Carlo Estimation of Volumetric Path Integrals</a></li>
  <li><a href="#visual-results" id="toc-visual-results" class="nav-link" data-scroll-target="#visual-results">Visual Results!</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Foggy Cornell Box</h1>
<p class="subtitle lead">Micro Blog: Volumetric Path Tracer</p>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 15, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../img/blog/10_volumetric_cornell_high_sample.gif" class="img-fluid figure-img"></p>
<figcaption>Foggy rotating Cornell box best viewed in dark mode with an eye-watering sampling rate of <span class="math inline">\(512^2=262,144\)</span> sample per pixel.</figcaption>
</figure>
</div>
<p>An attempt at creating the most basic volumetric path tracer: Cornell box in foggy atmosphere that is <em>uniformly</em> diffused within the air. Overall concepts will be based on <span class="citation" data-cites="pharr2023physically">Pharr, Jakob, and Humphreys (<a href="#ref-pharr2023physically" role="doc-biblioref">2023, chap. 11</a>)</span> and <span class="citation" data-cites="pharr2023physically">Pharr, Jakob, and Humphreys (<a href="#ref-pharr2023physically" role="doc-biblioref">2023, chap. 14</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><section id="volumetric-scattering-model" class="level1 page-columns page-full">
<h1>Volumetric Scattering Model</h1>
<p>In basic volumetric rendering, there are four more assumptions (on top of surface scattering) based on the underlying physical processes of these three main <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> types of light interaction with participating media <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>: absorption, emission, and scattering.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;<span class="citation" data-cites="chandrasekhar2013radiative">Chandrasekhar (<a href="#ref-chandrasekhar2013radiative" role="doc-biblioref">2013, chap. 1</a>)</span> nicely put it as ‚Äúwe shall not aim at the maximum generality possible but limit ourselves, rather, by the situations which the problem considered in this book actually required.‚Äù So in terms of the <em>theory</em> behind the volumetric light transport in participating media itself, it <em>really</em> is just these four main types of interaction to consider. Anything else is likely unnecessarily complicated.</p></div><div id="fn2"><p><sup>2</sup>&nbsp;Volumetric rendering is not necessarily associated with participating media. You can do volumetric rendering on surface-only scenes, but that would unnecessarily complicate and slow-down the rendering.</p></div></div><p>1st assumption: <strong>Absorption</strong>. <span class="math inline">\(dL_o(\mathbf{x},\omega)=-\sigma_a(\mathbf{x},\omega)L_i(\mathbf{x},-\omega) dt\)</span></p>
<p>2nd assumption: <strong>Emission</strong><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. <span class="math inline">\(dL_o(\mathbf{x},\omega)=\sigma_a(\mathbf{x},\omega)L_i(\mathbf{x},-\omega) dt\)</span></p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;According to <span class="citation" data-cites="chandrasekhar2013radiative">Chandrasekhar (<a href="#ref-chandrasekhar2013radiative" role="doc-biblioref">2013, chap. 4</a>)</span>, the emission <em>of the participating media</em> uses the same absorption coefficient, except negated, since Kirchhoff‚Äôs law states the absorbing media must be at thermal equilibrium, which means it also needs to emit at the same rate to ensure the media does not keep gaining energy, unless externally sourced (which we assume not for now).</p></div><div id="fn4"><p><sup>4</sup>&nbsp;One might ask if in-scattering has a phase function, why does out-scattering not have a phase function? <span class="citation" data-cites="chandrasekhar2013radiative">Chandrasekhar (<a href="#ref-chandrasekhar2013radiative" role="doc-biblioref">2013, chap. 3</a>)</span> actually shows out-scattering does, but it does not depend on the variation of radiance (i.e., intensity and color), since there‚Äôs only one kind of intensity and color, it merely reduced down to the coefficient <span class="math inline">\(\sigma_s\)</span>.</p><div id="ref-chandrasekhar2013radiative" class="csl-entry" role="listitem">
Chandrasekhar, S. 2013. <em>Radiative Transfer</em>. Dover Books on Physics. Dover Publications. <a href="https://books.google.com/books?id=1YHCAgAAQBAJ">https://books.google.com/books?id=1YHCAgAAQBAJ</a>.
</div></div></div><p>3rd assumption: <strong>Out-scattering</strong><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. <span class="math inline">\(dL_o(\mathbf{x},\omega)=-\sigma_s(\mathbf{x},\omega)L_i(\mathbf{x},-\omega) dt\)</span></p>
<p>This is one of two types of scattering that models the reduction of radiance along a ray when it scatters away from the direction of the ray.</p>
<p>4th assumption: <strong>In-scattering</strong>. <span class="math inline">\(\displaystyle dL_o(\mathbf{x},\omega)=\sigma_s(\mathbf{x},\omega)\int_{S^2}p(\mathbf{x},\omega_i,\omega)L_i(\mathbf{x},\omega_i)d\omega_i\)</span></p>
<p>This is the other type of scattering that models the increase of radiance along a ray when it scatters into the direction of the ray.</p>
<p>Notice that absorption and out-scattering removes radiance while emission and in-scattering adds radiance. We group absorption and out-scattering together into attenuation/extinction coefficient <span class="math inline">\(\sigma_\text{t}=\sigma_a+\sigma_s\)</span> that describes the overall reduction of the radiance along the ray (i.e., <span class="math inline">\(dL_o(\mathbf{x},\omega)=-\sigma_\text{t}(\mathbf{x},\omega)L_i(\mathbf{x},-\omega) dt\)</span>). Additionally, we also have a single-scattering albedo, <span class="math inline">\(\rho(\mathbf{x},\omega)=\frac{\sigma_s(\mathbf{x},\omega)}{\sigma_\text{t}(\mathbf{x},\omega)}\)</span>, which describes the ratio on how much it scatters rather than absorbed. As for the other two, we merge both in-scattering and emission into <span class="math inline">\(dL_o(\mathbf{x},\omega)=\sigma_\text{t}(\mathbf{x},\omega)L_s(\mathbf{x},\omega)dt\)</span> where the source function <span class="math inline">\(L_s\)</span> is <span class="math inline">\(\displaystyle L_s(\mathbf{x},\omega):=\frac{\sigma_a(\mathbf{x},\omega)}{\sigma_\text{t}(\mathbf{x},\omega)}L_e(\mathbf{x},\omega)+\rho(\mathbf{x},\omega)\int_{S^2}p(\mathbf{x},\omega_i,\omega)L_i(\mathbf{x},\omega_i)d\omega_i\)</span>.</p>
<p>We will first assume the fog is a perfect scattering of a participating media with isotropic scattering<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> (i.e., no absorption; no emission; constant phase function) So how does one even render it?</p>
<div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;Isotropic media is not the same as isotropic phase function, where the former refers particles with uniform <em>arrangements</em> or having a very round <em>shape</em> while the latter refers to whether the full-spherical <em>scattering</em> is uniform.</p></div></div><p>Now, before we get to that, there‚Äôs more intermediate structure we have to build. Currently, these fundamental assumption of volumetric physical processes are defined via differential equations, since these processes constantly involves with the spatial medium that permeates the ‚Äúair‚Äù as it traverses through it. This makes diff. eqs. a natural description of how a ray <em>incrementally change</em> in radiance as it <em>incrementally</em> traverse the media. Modelling surface-only effects (e.g., traditional BSDF) only cares about physical processes at discrete amount of bounces on each surfaces; hence, diff. eqs. is unnecessary. However, most renderer is based on integral formulations since we mostly care about the overall radiance produced before the sensor instead of the local effects of volumetric or surface scattering (in the grand scheme of things). So, we need to somehow convert these diff. eqs. to integrals first in order to apply common rendering algorithms on these new volumetric assumptions.</p>
<section id="transmittance" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="transmittance">Transmittance</h2>
<p>First, let us look into the extinction portion of the volumetric effects: <span class="math inline">\(dL_o(\mathbf{x}, \omega) = -\sigma_\text{t}(\mathbf{x}, \omega) L_i(\mathbf{x}, -\omega)dt\)</span>, which is more explicitly written as <span class="math inline">\(dL_o(\mathbf{x}+t\omega, \omega) = -\sigma_\text{t}(\mathbf{x}+t\omega, \omega) L_i(\mathbf{x}+t\omega, -\omega)dt\)</span>. When <span class="math inline">\(t=0\)</span>, we are at <span class="math inline">\(\mathbf{x}\)</span>. whereas we denote the location of <span class="math inline">\(\mathbf{x}'\)</span> along the direction <span class="math inline">\(\omega\)</span> when the ray has traversed to time <span class="math inline">\(t\)</span>.</p>
<p></p>
<p><span class="math display">\[\begin{align}

dL_o(\mathbf{x}+t\omega, \omega) &amp;= -\sigma_\text{t}(\mathbf{x}+t\omega, \omega) L_i(\mathbf{x}+t\omega, -\omega)dt \\
dL_o(\mathbf{x}+t\omega, \omega) &amp;= -\sigma_\text{t}(\mathbf{x}+t\omega, \omega) L_o(\mathbf{x}+t\omega, \omega)dt

\end{align}\]</span></p>
<p>For the sake of brevity, we will abbreviate the notation and re-introduce them later. Pro tip: always use definite integral; indefinite integral causes a lot of confusion in these complicated settings, especially with nested variables like here.</p>
<p><span class="math display">\[\begin{align}

dL_o &amp;= -\sigma_\text{t} L_o dt \\
\frac{1}{L_o} \frac{dL_o}{dt} &amp;= -\sigma_\text{t} \\
\int^{t=d}_{t=0} \frac{1}{L_o} \frac{dL_o}{dt} dt &amp;= \int^{t=d}_{t=0} -\sigma_\text{t} dt \\
\int^{L_o(t=d)}_{L_o(t=0)} \frac{dL_o}{L_o} &amp;= \int^{t=d}_{t=0} -\sigma_\text{t} dt \\
\ln{|L_o(t=d)|}-\ln{|L_o(t=0)|} &amp;= \int^{t=d}_{t=0} -\sigma_\text{t} dt \\
\frac{L_o(t=d)}{L_o(t=0)} &amp;= e^{\int^{t=d}_{t=0} -\sigma_\text{t} dt} \\
\frac{L_o(\mathbf{x}+d\omega, \omega)}{L_o(\mathbf{x}, \omega)} &amp;= e^{-\int^{t=d}_{t=0} \sigma_\text{t} dt} \\
\frac{L_o(\mathbf{x}', \omega)}{L_o(\mathbf{x}, \omega)} &amp;= e^{-\int^{t=d}_{t=0} \sigma_\text{t} dt} \\

\end{align}\]</span></p>
<p>This perfectly matches the book‚Äôs <em>definition</em> of transmittance <span class="math inline">\(T_r(\mathbf{x}\to\mathbf{x}'):=\frac{L_o(\mathbf{x}', \omega)}{L_o(\mathbf{x}, \omega)}\)</span> where it is always between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, which will be important for our rendering algorithm as a nice way to encapsulate the idea of absorption and out-scattering as an accumulated transmittance on a point along a ray. This is better related to an idea known as attenuation. Additionally, the exponent in the transmittance, <span class="math inline">\(-\int^{t=d}_{t=0} \sigma_\text{t} dt\)</span>, refers to <em>optical thickness/depth</em>, which just tells us how much the light is scattered or absorbed in total (linearly) different from the exponentiated version that tells us what the actual final radiance produced.</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;Since <span class="math inline">\(\mathbf{x}'\)</span> represents a point later, or further away, from the light source then <span class="math inline">\(\mathbf{x}\)</span>, its outgoing radiance must at most be the same or reduced, but not negative. Hence, <span class="math inline">\(T_r\in [0,1]\)</span>. Can also be thought of as the <em>fraction</em> between the radiance of the earlier <span class="math inline">\(\mathbf{x}\)</span> and the later <span class="math inline">\(\mathbf{x}'\)</span>.</p></div></div></section>
<section id="the-equation-of-transfer" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-equation-of-transfer">The Equation of Transfer</h2>
<p>Transmittance only talks about all the processes that involves reducing the radiance, which is only a part of it. What about the rest? One neat thing about all the assumed equations‚Ä¶ they all modify/change the same underlying <span class="math inline">\(L_o\)</span>! So, we can <em>aggregate</em> each of these individual processes into one diff. eq.: <span class="math inline">\(dL_o(\mathbf{x}+t\omega, \omega) = -\sigma_\text{t}(\mathbf{x}+t\omega, \omega) L_i(\mathbf{x}+t\omega, -\omega)dt + \sigma_\text{t}(\mathbf{x}+t\omega, \omega) L_s(\mathbf{x}+t\omega, \omega)dt\)</span> to be integrated. As usual, we will abbreviate the notation for brevity. When the ray <span class="math inline">\((\mathbf{x},\omega)\)</span> intersects a surface, we will denote the location of intersection as <span class="math inline">\(\mathbf{x}_s\)</span> in which the ray has traveled <span class="math inline">\(t=d\)</span>.</p>
<p><span class="math display">\[\begin{align}

dL_o &amp;= -\sigma_\text{t} L_idt + \sigma_\text{t} L_sdt \\
dL_o &amp;= -\sigma_\text{t} L_odt + \sigma_\text{t} L_sdt \\
\frac{dL_o}{dt} + \sigma_\text{t} L_o &amp;= \sigma_\text{t} L_s \\
(e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) \frac{dL_o}{dt} + (e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) \sigma_\text{t} L_o &amp;= (e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) \sigma_\text{t} L_s \\
(e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) \frac{dL_o}{dt} + (e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) (\frac{d}{dt} \int^{s=t}_{s=0}\sigma_\text{t} ds) L_o &amp;= (e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) \sigma_\text{t} L_s \\
\int^{t=d}_{t=0} \frac{d}{dt} (e^{\int^{s=t}_{s=0} \sigma_\text{t} ds} L_o) dt &amp;= \int^{t=d}_{t=0} (e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) \sigma_\text{t} L_s dt \\
e^{\int^{s=d}_{s=0} \sigma_\text{t} ds} L_o(t=d) - e^{\int^{s=0}_{s=0} \sigma_\text{t} ds} L_o(t=0) &amp;= \int^{t=d}_{t=0} (e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) \sigma_\text{t} L_s dt \\
L_o(t=d)  &amp;= e^{-\int^{s=d}_{s=0} \sigma_\text{t} ds} L_o(t=0) + e^{-\int^{s=d}_{s=0} \sigma_\text{t} ds} \int^{t=d}_{t=0} (e^{\int^{s=t}_{s=0} \sigma_\text{t} ds}) \sigma_\text{t} L_s dt \\
L_o(t=d)  &amp;= e^{-\int^{s=d}_{s=0} \sigma_\text{t} ds} L_o(t=0) + \int^{t=d}_{t=0} (e^{-\int^{s=d}_{s=t} \sigma_\text{t} ds}) \sigma_\text{t} L_s dt \\
L_o(t=d)  &amp;= T_r(\mathbf{x}\to\mathbf{x}_s) L_o(t=0) + \int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}_s) \sigma_\text{t} L_s dt

\end{align}\]</span></p>
<p>However, this is calculated in the direction towards the point of intersection starting from <span class="math inline">\(\mathbf{x}\)</span>. For the sake of convention, we will reformulate this as a ray marching towards the surface intersection but pointing back to <span class="math inline">\(\mathbf{x}\)</span> by negating the direction <span class="math inline">\(\omega\)</span> as a way to compute the incoming radiance <span class="math inline">\(L_i\)</span> at <span class="math inline">\(\mathbf{x}\)</span> from the surface intersection (and all the volumetric effects that occurs in-between). The equation can be intuitively understood as summing the incremental volumetric effects from the attenuated incoming radiance along the ray (i.e., line integral) and the additional effects from the surface scattering attenuated at the entire length. <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn7"><p><sup>7</sup>&nbsp;Note, the book uses <span class="math inline">\(\sigma_\text{t}(\mathbf{x}',\omega)\)</span> with the un-negated direction <span class="math inline">\(\omega\)</span> likely from different parameterization. However, as long as the attenuation coefficient is directionally symmetric, <span class="math inline">\(\sigma_\text{t}(\mathbf{x}',\omega)=\sigma_\text{t}(\mathbf{x}',-\omega)\)</span>, which occurs in most basic volumetric media, then this discrepancy can be ignored with discretion.</p></div></div><p>The Equation of Transfer (Integral Form):</p>
<p><span class="math display">\[
L_i(\mathbf{x},\omega) = T_r(\mathbf{x}_s\to\mathbf{x}) L_o(\mathbf{x}_s,-\omega) + \int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \sigma_\text{t}(\mathbf{x}',-\omega) L_s(\mathbf{x}',-\omega) dt
\]</span></p>
<p>Another important idea is when there are no surface scattering along the path the ray travels. Then, <span class="math inline">\(d\to\infty\)</span>, <span class="math inline">\(\mathbf{x}_s\)</span> is undefined, and no surface scattering at <span class="math inline">\(d\)</span> to emit the first term of The Equation of Transfer.</p>
</section>
</section>
<section id="volumetric-light-transport" class="level1 page-columns page-full">
<h1>Volumetric Light Transport</h1>
<p>Now, we have all the necessary diff. eqs. converted into integral form, we can try incorporating volumetric effects into our core rendering algorithm. But before we do that (I know), our current formulation only supports local light transport since it only specifies for a single ray (i.e., no bounce). Now, we have to extend them into the path-space integral formulation for supporting global light transport (i.e., multi-bounce).</p>
<p>While the book provides the full theoretical generalization of volumetric path integral, it doesn‚Äôt tell us how we should implement our own renderer in a clear way. We will re-devise our own formulation that closely resembles the rendering algorithm itself with next-event estimation (NEE). <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> To simplify the formulation, we will apply our own assumption of the sampling process to simplify the math &amp; the algorithm while keeping the accuracy of our rendering.</p>
<div class="no-row-height column-margin column-container"><div id="fn8"><p><sup>8</sup>&nbsp;It is important to get a good looking rendering that is simple, fast, and unbiased. NEE should do the job in the volumetric case.</p></div></div><p>Recall our equation of transfer and the source function <span class="math inline">\(L_s\)</span>:</p>
<p><span class="math display">\[
L_i(\mathbf{x},\omega) = T_r(\mathbf{x}_s\to\mathbf{x}) L_o(\mathbf{x}_s,-\omega) + \int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \sigma_\text{t}(\mathbf{x}',-\omega) L_s(\mathbf{x}',-\omega) dt
\]</span> <span class="math display">\[
L_s(\mathbf{x},\omega):=\frac{\sigma_a(\mathbf{x},\omega)}{\sigma_\text{t}(\mathbf{x},\omega)}L_e(\mathbf{x},\omega)+\rho(\mathbf{x},\omega)\int_{S^2}p(\mathbf{x},\omega_i,\omega)L_i(\mathbf{x},\omega_i)d\omega_i
\]</span></p>
<p>Simplifying results until we get a recursive form in <span class="math inline">\(L_i\)</span> (which depends on <span class="math inline">\(\omega_i\)</span>) <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>:</p>
<div class="no-row-height column-margin column-container"><div id="fn9"><p><sup>9</sup>&nbsp;We assume BRDF (no BTDF) for our BSDF.</p></div></div><p><span class="math display">\[\begin{align}

L_i(\mathbf{x},\omega) &amp;= T_r(\mathbf{x}_s\to\mathbf{x}) \bigg(L_e + \int_{H^2(\mathbf{n})}fL_i|\cos(\theta_i)|d\omega_i\bigg) + \int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \sigma_\text{t} \bigg(\frac{\sigma_a}{\sigma_\text{t}}L_e+\rho\int_{S^2}pL_id\omega_i\bigg) dt \\
&amp;= T_r(\mathbf{x}_s\to\mathbf{x}) \bigg(L_e + \int_{H^2(\mathbf{n})}fL_i|\cos(\theta_i)|d\omega_i\bigg) + \int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \bigg(\sigma_aL_e+\sigma_s\int_{S^2}pL_id\omega_i\bigg) dt

\end{align}\]</span></p>
<p>Since there‚Äôs two <span class="math inline">\(L_i\)</span> in this recursion, we have branching where one in the surface scattering and the other in the volumetric scattering. To continue the convention of path tracing with single sample equalling to single path, we have to figure out how we should split the branch. We can definitely randomly branch between these two and have these value average at the final output from other sampled paths, but as usual in computer graphics, there‚Äôs <em>usually</em> a better way (i.e., variance reduction). Intuitively, instead of uniform sampling, we can think of the chance/probability of reaching to the end <span class="math inline">\(\mathbf{x}_s\)</span> (i.e., the surface) as it‚Äôs transmittance between the surface intersection point (via a ray-intersection test) and the query point <span class="math inline">\(\mathbf{x}\)</span>.</p>
<section id="quick-tangent-variance-reduction-of-l_i" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="quick-tangent-variance-reduction-of-l_i">Quick Tangent: Variance Reduction of <span class="math inline">\(L_i\)</span></h2>
<p><strong>Disclaimer: it did not work out at the end. The variance actually increases since when doing this, if it hit‚Äôs the lower probability, it adds a multiplicative factor that makes the value <em>vary more</em> as the probability goes to the extrema (i.e., <span class="math inline">\(\to 0\)</span> or <span class="math inline">\(\to 1\)</span>).</strong> Feel free to skip this sub-section of my attempt at variance reduction. <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn10"><p><sup>10</sup>&nbsp;<span class="citation" data-cites="pharr2023physically">Pharr, Jakob, and Humphreys (<a href="#ref-pharr2023physically" role="doc-biblioref">2023, sec. 14.1.2</a>)</span> actually discussed about this issue similarly. However, they used null scattering technique which seems like to reduce the variance. However, despite us assuming homogenous medium, we will defer this for a later micro blog for progression sake.</p></div><div id="fn11"><p><sup>11</sup>&nbsp;With these analysis on variance reduction between various random variables, there‚Äôs a potential issue with <em>correlation</em> that can negatively affect the analysis, which we won‚Äôt bother for now.</p></div></div><p>Suppose the following:</p>
<p><span class="math display">\[
L_i' = \begin{cases}
\displaystyle L_e + \int_{H^2(\mathbf{n})}fL_i|\cos(\theta_i)|d\omega_i &amp; \text{with probability } T_r(\mathbf{x}_s\to\mathbf{x})  \\
\displaystyle \frac{\int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \bigg(\sigma_aL_e+\sigma_s\int_{S^2}pL_id\omega_i\bigg) dt}{1-T_r(\mathbf{x}_s\to\mathbf{x})} &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>We can show this is unbiased by expectation of sums of random variable (treating each of the two terms as random variable over all path samplings) and linearity of expectation. But does it reduce the variance? Let us analyze it.</p>
<p>Let us additionally suppose the uniform sampling case for comparison:</p>
<p><span class="math display">\[
L_i'' = \begin{cases}
\displaystyle 2T_r(\mathbf{x}_s\to\mathbf{x})(L_e + \int_{H^2(\mathbf{n})}fL_i|\cos(\theta_i)|d\omega_i) &amp; \text{with probability } \frac{1}{2}  \\
\displaystyle 2\int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \bigg(\sigma_aL_e+\sigma_s\int_{S^2}pL_id\omega_i\bigg) dt &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>Let <span class="math display">\[\begin{multline}
\\
T:=T_r(\mathbf{x}_s\to\mathbf{x}) \\
A:=L_e+\int_{H^2(\mathbf{n})}fL_i|\cos(\theta_i)|d\omega_i \\
B:=\int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \bigg(\sigma_aL_e+\sigma_s\int_{S^2}pL_id\omega_i\bigg) dt
\end{multline}\]</span></p>
<p>We can find the variance of the uniform sampling as follows:</p>
<p><span class="math display">\[\begin{align}

\mathrm{Var}(L_i'') &amp;= \mathbb{E}[L_i''^2]-\mathbb{E}[L_i'']^2 \\
&amp;= \frac{1}{2}\mathbb{E}[2AT]^2+\frac{1}{2}\mathbb{E}[2B]^2-(\frac{1}{2}\mathbb{E}[2AT]+\frac{1}{2}\mathbb{E}[2B])^2 \\
&amp;= \frac{1}{2}\mathbb{E}[2AT]^2+\frac{1}{2}\mathbb{E}[2B]^2-\frac{1}{4}\mathbb{E}[2AT]^2-\frac{1}{4}\mathbb{E}[2B]^2-\frac{1}{2}\mathbb{E}[2AT]\mathbb{E}[2B] \\
&amp;= \frac{1}{4}\mathbb{E}[2AT]^2+\frac{1}{4}\mathbb{E}[2B]^2-\frac{1}{2}\mathbb{E}[2AT]\mathbb{E}[2B] \\
&amp;= \mathbb{E}[AT]^2+\mathbb{E}[B]^2-2\mathbb{E}[AT]\mathbb{E}[B]

\end{align}\]</span></p>
<p>It seems like something <span class="math inline">\(\mathrm{Var}(L_i)\)</span> would have at the end‚Äìas in the variance if we had computed the original expression with branched recursion. Now, what about the proposed method in reducing the variance?</p>
<p><span class="math display">\[\begin{align}

\mathrm{Var}(L_i') &amp;= \mathbb{E}[L_i'^2]-\mathbb{E}[L_i']^2 \\
&amp;= T\mathbb{E}[A]^2+(1-T)\mathbb{E}\bigg[\frac{B}{1-T}\bigg]^2-\bigg(T\mathbb{E}[A]+(1-T)\mathbb{E}\bigg[\frac{B}{1-T}\bigg]\bigg)^2 \\
&amp;= T\mathbb{E}[A]^2+(1-T)\mathbb{E}\bigg[\frac{B}{1-T}\bigg]^2-T^2\mathbb{E}[A]^2-(1-T)^2\mathbb{E}\bigg[\frac{B}{1-T}\bigg]^2-2T(1-T)\mathbb{E}[A]\mathbb{E}\bigg[\frac{B}{1-T}\bigg] \\
&amp;= \frac{\mathbb{E}[TA]^2}{T}-\mathbb{E}[TA]^2+\frac{(1-T)}{(1-T)^2}\mathbb{E}[B]^2-\frac{(1-T)^2}{(1-T)^2}\mathbb{E}[B]^2-2\mathbb{E}[TA]\mathbb{E}[B] \\
&amp;= \frac{1-T}{T}\mathbb{E}[TA]^2+\frac{T}{(1-T)}\mathbb{E}[B]^2-2\mathbb{E}[TA]\mathbb{E}[B]
\end{align}\]</span></p>
<p>For the sake of comparison, we ignore the last term and assume <span class="math inline">\(\mathbb{E}[TA]\)</span> and <span class="math inline">\(\mathbb{E}[B]\)</span> are the same. This supposedly ‚Äúvariance reduction‚Äù actually only reaches the minimum variance at <span class="math inline">\(T=0.5\)</span> (<span class="math inline">\(T\)</span> for transmittance). In other words, the uniform sampling actually performs better than this method üò≥. While this was a fun tangent to the main goal, this also tells us that not all probabilistic conditional branching like here between the two terms in the recursion can be variance reduced for all probability (e.g., <span class="math inline">\(T\)</span>), especially when the variance expression grows inversely at both ends ü§¶. Unlike Russian roulette where it only inversely grows on one end and the probability is a set constant (i.e., hyperparameter). We will leave it as uniform sampling and leaving this here for posterity.</p>
<!-- This recursive form is a step closer, but does not allow us to consider the impact of path length (i.e., depth) in the rendering process and the global structure. We have to unravel this recursion!

Given a path, we have to know its beginning and its end. We commonly assume we start with the vertex $\mathbf{x}_0$ that corresponds to the pixel location of the output image of a sensor. As for the ending, we always want it to be some strong emissive source. Rendering is not rendering if there's no light üò≤üò≤üò≤. Hence, after some $N$ bounces, $\mathbf{x}_N$ will be the final vertex, which should always be some emissive source $L_e$. With NEE, every bounce must always try sampling the light source. -->
<!-- Everytime you see an integral, it should scream Monte-Carlo sampling. However, we can't our assumptions of the sampling process right now -->
</section>
<section id="continuation-solving-recursion-with-operators" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="continuation-solving-recursion-with-operators">Continuation: Solving recursion with operators</h2>
<p>A well-defined path is a finite path. With any finite path, it has a defined length <span class="math inline">\(N\)</span> by <span class="math inline">\(N-1\)</span> bounces with <span class="math inline">\(N+1\)</span> vertices and, logically, has two ends (i.e., no branching). <a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> One end always correspond to its respective pixel location <span class="math inline">\(\mathbf{x}_p\)</span> of the sensor‚Äôs output image. What‚Äôs the point of sampling a path that never reaches to our sensor for you or others to see? For the other end, we should aim for sampling emissive sources <span class="math inline">\(\mathbf{x}_l\)</span> ordered by its radiance strength. Rendering is really not rendering if there‚Äôs no light üò≤ to spatially mediate the information of a scene. For NEE, we actually do use simple branching at every vertices except the last (I lied; I‚Äôm very sorry), but the branched ends is at most a length of <span class="math inline">\(1\)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn12"><p><sup>12</sup>&nbsp;It can still physically travel infinitely where the path goes on forever <em>pointing</em> towards the sky/space (assuming no atmospheric scattering), but that breaks our algorithm with our finite amount of computational resources. Hence, the path is defined by finite amount of <em>bounces</em> (i.e., <em>interesting</em> scattering events), which can still be flexible in modelling reality.</p></div><div id="fn13"><p><sup>13</sup>&nbsp;In <span class="citation" data-cites="pharr2023physically">Pharr, Jakob, and Humphreys (<a href="#ref-pharr2023physically" role="doc-biblioref">2023, sec. 14.2.1</a>)</span>, their provided algorithm for <span class="math inline">\(L_i\)</span> notably shows a random selection between three terms for evaluation per <span class="citation" data-cites="pharr2023physically">Pharr, Jakob, and Humphreys (<a href="#ref-pharr2023physically" role="doc-biblioref">2023</a>, Equation 14.5)</span>: volumetric emission, in-scattering, and null scattering. Since we assume no volumetric emission and null scattering, we will evaluate each term in the source function <span class="math inline">\(L_s\)</span> as usual. Volumetric emission is left for completion sake and consistency from previous derivation, but will be removed at the right time. In fact, in their <code>VolPathIntegrator</code>, they re-added the absorption/emission case as always sampled/evaluated along the ray in the medium.</p></div><div id="fn14"><p><sup>14</sup>&nbsp;For <code>VolPathIntegrator</code> in <span class="citation" data-cites="pharr2023physically">Pharr, Jakob, and Humphreys (<a href="#ref-pharr2023physically" role="doc-biblioref">2023</a>)</span>, their probabilistic conditional branching between <em>inhomogeneous</em> medium scattering and surface scattering works by whether the medium has sampled a null scattering event (neither terminated nor scattered). This makes sense. If there‚Äôs some empty area in the medium, it will <em>likely</em> ‚Äúhit‚Äù some null scattering, and given enough luck, it can travel to the end of the medium and hit a surface. However, we‚Äôre not assuming inhomogeneous medium and not delta tracking method (for now), so we just uniform sample between surface intersection and medium intersection.</p><div id="ref-pharr2023physically" class="csl-entry" role="listitem">
Pharr, M., W. Jakob, and G. Humphreys. 2023. <em>Physically Based Rendering, Fourth Edition: From Theory to Implementation</em>. MIT Press. <a href="https://books.google.ad/books?id=kUtwEAAAQBAJ">https://books.google.ad/books?id=kUtwEAAAQBAJ</a>.
</div></div></div><p>If we rewrite our newly formed recursion as the following‚Ä¶<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> <span class="math display">\[
L_i = \begin{cases}
\displaystyle 2T_r(\mathbf{x}_s\to\mathbf{x})(L_e + \int_{H^2(\mathbf{n})}fL_id\sigma^\perp(\omega_i)) &amp; \text{with probability } \frac{1}{2}  \\
\displaystyle 2\int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \bigg(\sigma_aL_e+\sigma_s\int_{S^2}pL_id\sigma(\omega_i)\bigg) dt &amp; \text{otherwise}
\end{cases}
\]</span></p>
<!-- This will closely match with the general style of our algorithm. We can generalize this into a path-space integral formulation for more theoretical analysis, notably variance reduction. However, since we're not really doing anything fancy with the sampling, we will defer the generalization for this specific time. -->
<p>However, it‚Äôs the best if we can convert this form into a general path space integral formulation to potentially apply variance reduction techniques and better analyze which variables (e.g., throughput) to track across scattering events.<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> To unravel this recursion, we actually abstract the equation an order more via functional analysis to better see the bigger picture and use the tools from them to analytically solve the recursion! We can treat the output quantity of the recursion as an expectation to also abstract the notion of probability away. Let‚Äôs start with the abstraction first with operators:</p>
<div class="no-row-height column-margin column-container"><div id="fn15"><p><sup>15</sup>&nbsp;According to many sources, path space integral formulation allows us to unify various formulation of path tracing (e.g., ‚Äúthe rendering equation‚Äù), enabling the application of advanced variance reduction techniques (e.g., bidirectional path tracer) and some other exotic stuff. These are definitely beyond the scope, but it‚Äôs on our radar.</p></div></div><p>We have to abstract emission first. <span class="math inline">\(S\)</span> is a set of points (parameterized two-dimensionally) that defines a surface in our scene. <span class="math display">\[
(\mathcal{E}h)(\mathbf{x},\omega) = \begin{cases}
L_e(\mathbf{x},\omega) &amp; \mathbf{x}\in S  \\
\sigma_a(\mathbf{x},\omega)L_e(\mathbf{x},\omega) &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>Following <span class="citation" data-cites="jakob2013light">Jakob (<a href="#ref-jakob2013light" role="doc-biblioref">2013, sec. 3.2</a>)</span>, we define the scattering operator <span class="math inline">\(\mathcal{K}\)</span> and propagation operator <span class="math inline">\(\mathcal{G}\)</span> as follows.</p>
<div class="no-row-height column-margin column-container"></div><p><span class="math display">\[
(\mathcal{K}h)(\mathbf{x},\omega) := \begin{cases}
\displaystyle \int_{H^2(\mathbf{n})}f(\mathbf{x},\omega_i\to\omega)h(\mathbf{x},\omega_i)d\sigma^\perp_\mathbf{x}(\omega_i) &amp; \mathbf{x}\in S  \\
\displaystyle \sigma_s(\mathbf{x},\omega)\int_{S^2}p(\mathbf{x},\omega_i\to\omega)h(\mathbf{x},\omega_i)d\sigma_\mathbf{x}(\omega_i) &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>Since <span class="math inline">\(f\leq1\)</span>, <span class="math inline">\(p\leq1\)</span>, <span class="math inline">\(\sigma_s\leq1\)</span>, <span class="math inline">\(d\sigma^\perp_\mathbf{x}(\omega_i)\leq1\)</span>, and <span class="math inline">\(d\sigma^\perp_\mathbf{x}(\omega_i)&lt;1\)</span>, the operator norm of <span class="math inline">\(\mathcal{K}\)</span> is less than or equal to <span class="math inline">\(1\)</span> (i.e., <span class="math inline">\(||\mathcal{K}||\leq 1\)</span>). <a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn16"><p><sup>16</sup>&nbsp;This is more talked about in <span class="citation" data-cites="veachthesis">Veach (<a href="#ref-veachthesis" role="doc-biblioref">1998, sec. 4.2</a>)</span>, where this and the next operator are actually operated on a space of integrations between two functions on ray space. This space can be further constructed as the <em>Banach space</em> (i.e., <span class="math inline">\(L_p\)</span> space), or further down as the <em>Hilbert space</em> (i.e., inner product space), which allows the construction of operator norms.</p><div id="ref-veachthesis" class="csl-entry" role="listitem">
Veach, Eric. 1998. <span>‚ÄúRobust Monte Carlo Methods for Light Transport Simulation.‚Äù</span> PhD thesis, Stanford, CA, USA: Stanford University.
</div></div></div><p><span class="math display">\[
(\mathcal{G}h)(\mathbf{x},\omega) := \begin{cases}
\displaystyle 2T_r(\mathbf{x}_s\to\mathbf{x})h(\mathbf{x}_s,-\omega) &amp;  \text{with probability } \frac{1}{2}  \\
\displaystyle 2\int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) h(\mathbf{x}',-\omega) dt &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>Here, <span class="math inline">\(T_r\leq1\)</span>; hence, <span class="math inline">\(||\mathcal{G}||\leq1\)</span>.</p>
<p>All three operators are can be merely thought of as macros, lambdas, or higher-order functions that operates at a level more abstract, where it takes in a function and outputs a modified function. Collectively, <span class="math inline">\(\mathcal{K}\)</span> and <span class="math inline">\(\mathcal{G}\)</span> can be thought of as the transport operators, since they merely transport the radiance and follow the conservation law of energy. Hence, the recursion can be simplified as follows, which strips away branching and integral expression details for the more important parts.</p>
<p><span class="math display">\[
L_i = \mathcal{G}(\mathcal{K}L_i + \mathcal{E}L_e)
\]</span></p>
<p>Now, we solve the recursion. <a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn17"><p><sup>17</sup>&nbsp;If you do the other way, you might get <span class="math inline">\(L_i=(\mathcal{G}^{-1} - \mathcal{K})^{-1}\mathcal{E}L_e\)</span>, which is more complicated, or even impossible, to solve.</p></div></div><p><span class="math display">\[
\begin{align}
L_i = \mathcal{G}\mathcal{K}L_i + \mathcal{G}\mathcal{E}L_e &amp;\implies L_i - \mathcal{G}\mathcal{K}L_i= \mathcal{G}\mathcal{E}L_e \\
&amp;\implies (\mathcal{I} - \mathcal{G}\mathcal{K})L_i= \mathcal{G}\mathcal{E}L_e \\
&amp;\implies L_i= (\mathcal{I} - \mathcal{G}\mathcal{K})^{-1}\mathcal{G}\mathcal{E}L_e
\end{align}
\]</span></p>
<p>Great! It‚Äôs no longer a recursion, but‚Ä¶ how do we even compute the inverse of an operator <span class="math inline">\((\mathcal{I} - \mathcal{G}\mathcal{K})^{-1}\)</span>? (We‚Äôre not even talking about the function themselves anymore.) Neumann series has a solution for us, which is a formula that extends the convergence of geometric series (over scalars) to over operators. However, it requires <span class="math inline">\(||\mathcal{G}\mathcal{K}||&lt;1\)</span>.</p>
<p>This is easy. Recall <span class="math inline">\(||\mathcal{G}||\leq1\)</span> and <span class="math inline">\(||\mathcal{K}||\leq1\)</span>. The only time either is <span class="math inline">\(1\)</span> is when the scene is perfectly vacant and probably some other degenerative cases that we can ignore. Out of practicaly, we can assume that‚Äôs not the case and we can apply the Nuemann series to get the following.</p>
<p><span class="math display">\[
L_i= \sum_{k=0}^\infty (\mathcal{G}\mathcal{K})^k \mathcal{G}\mathcal{E}L_e
\]</span></p>
<p>We started with the differential equations and integro-differential form that closely describes the physical processes of volumetric scattering at a local level. Then, we re-express them into the recursive integral formulation‚Äìthe equation of transfer‚Äìwhich prepares for the global light transport. The operators helps us re-express, again, the equation of transfer as a summation of increasing path length. Currently, this global light transport does not restrict the start/end (doesn‚Äôt matter) of the path with the sensor, which was briefly mentioned in the first paragraph of this section regarding <span class="math inline">\(\mathbf{x}_p\)</span>. We will address this in the next section with the sensor measurement integral that fixes the global light transport to sensors, allowing you to actually render the scene to your screen.</p>
<!-- We just have to re-expand the operators, shuffle the terms, and re-parameterize the integrals to the final form. -->
<!-- We first have to remove NEE, for analysis sake. We also assume no volumetric emission (i.e., fogs shouldn't be emitting any radiance in itself). Additionally, we assume the medium is everywhere and has no bounds. -->
<!-- We can rewrite the recursion as follows... -->
<!-- $$
L_i^n(L_e, L_i^{n+1}) = \begin{cases}
\displaystyle 2T_r(\mathbf{x}_s\to\mathbf{x})L_e & \text{with probability } \frac{1}{2} \text{ when } n=N \\
\displaystyle 2\int_{H^2(\mathbf{n})}T_r(\mathbf{x}_s\to\mathbf{x})fL_i^{n+1}|\cos(\theta_i)|d\omega_i & \text{with probability } \frac{1}{2} \text{ when } n\neq N  \\
\displaystyle 2\int^{t=d}_{t=0}\int_{S^2} T_r(\mathbf{x}'\to\mathbf{x}) \sigma_spL_i^{n+1}d\omega_i dt & \text{otherwise}
\end{cases}
$$ -->
<!-- Then, we can unwrap the recursion step-by-step: -->
<!-- \begin{align}

L_i^N(\mathbf{x}_p,\omega) &= T_r(\mathbf{x}_s\to\mathbf{x}) L_e \\
L_i^{N-1}(\mathbf{x}_p,\omega) &= T_r(\mathbf{x}_s\to\mathbf{x}) \bigg(\int_{H^2(\mathbf{n})}fL_i|\cos(\theta_i)|d\omega_i\bigg) + \int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \bigg(\sigma_s\int_{S^2}pL_id\omega_i\bigg) dt \\

\end{align}

\begin{align}

L_i(\mathbf{x}_p,\omega) &= T_r(\mathbf{x}_s\to\mathbf{x}) \bigg(L_e + \int_{H^2(\mathbf{n})}fL_i|\cos(\theta_i)|d\omega_i\bigg) + \int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \sigma_\text{t} \bigg(\frac{\sigma_a}{\sigma_\text{t}}L_e+\rho\int_{S^2}pL_id\omega_i\bigg) dt \\
&= T_r(\mathbf{x}_s\to\mathbf{x}) \bigg(L_e + \int_{H^2(\mathbf{n})}fL_i|\cos(\theta_i)|d\omega_i\bigg) + \int^{t=d}_{t=0} T_r(\mathbf{x}'\to\mathbf{x}) \bigg(\sigma_aL_e+\sigma_s\int_{S^2}pL_id\omega_i\bigg) dt

\end{align} -->
</section>
<section id="evaluating-path-integrals" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="evaluating-path-integrals">Evaluating path integrals</h2>
<p>Let <span class="math inline">\(I_j\)</span> be our per-pixel radiance measurement where <span class="math inline">\(j\)</span> refers to the pixel index where we want our radiance to be recorded to. Per <span class="citation" data-cites="jakob2013light">Jakob (<a href="#ref-jakob2013light" role="doc-biblioref">2013, sec. 3.4</a>)</span>, <span class="math inline">\(I_j:=\langle W_e^{(j)},L_i\rangle\)</span>. We eventually get <span class="math inline">\(\displaystyle I_j=\int_\Omega f_j(\overline{x})d\mu(\overline{x})\)</span>. You can read the sources more for the notation, but <span class="math inline">\(\Omega\)</span> is the domain of all path lengths <span class="math inline">\(N\)</span> <a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> from <span class="math inline">\(0\)</span> to <span class="math inline">\(\infty\)</span> bounces with each containing all <span class="math inline">\(2^N\)</span> combination of volumetric and surface scattering all eagerly evaluated (instead of the expectation, the integration evaluates all possible branches, theoretically). There are several key ideas: they let <span class="math inline">\((\mathcal{G}\mathcal{K})^k\mathcal{G}=\mathcal{G}(\mathcal{K}\mathcal{G})^k\)</span>, where <span class="math inline">\(\mathcal{K}\mathcal{G}\)</span> allows easier simplification. In volumetric scattering, given some integrand <span class="math inline">\(h\)</span>, we can simplify it as follows: <span class="math inline">\(\displaystyle \int_0^d\int_{S^2} hd\sigma_\mathbf{x}(\omega)dt=\int_0^d\int_{S^2} \frac{h}{t^2}dA(\mathbf{y})dt=\int_V \frac{h}{t^2}dV(\mathbf{y})\)</span><a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-jakob2013light" class="csl-entry" role="listitem">
Jakob, Wenzel Alban. 2013. <em>Light Transport on Path-Space Manifolds</em>. Cornell University.
</div><div id="fn18"><p><sup>18</sup>&nbsp;<span class="math inline">\(N\)</span> can be finite (instead of <span class="math inline">\(\infty\)</span> per Neumann series) because at a certain point the ratios will be smaller than the precision of common numerical datatypes on GPU.</p></div><div id="fn19"><p><sup>19</sup>&nbsp;Also mentioned in <span class="citation" data-cites="Zhang_2022">Zhang (<a href="#ref-Zhang_2022" role="doc-biblioref">2022</a>, Equation 2.19)</span></p><div id="ref-Zhang_2022" class="csl-entry" role="listitem">
Zhang, Cheng. 2022. <span>‚ÄúPath-Space Differentiable Rendering.‚Äù</span> <em>eScholarship, University of California</em>, October. <a href="https://escholarship.org/uc/item/25q5562p">https://escholarship.org/uc/item/25q5562p</a>.
</div></div></div><p>We are now getting very close to the final form that prepares us to finally render our foggy atmosphere! According to the sources (both the book and the thesis)‚Ä¶</p>
<p><span class="math display">\[
\begin{align}
f_j(\overline{\mathbf{x}}) &amp;= f_j(\mathbf{x}_p,\mathbf{x}_{N-1},\cdots,\mathbf{x}_{2},\mathbf{x}_1) \\
&amp;= \hat{L_e}(\mathbf{x}_{1}\to\mathbf{x}_{2})\bigg[\prod^{N-1}_{n=2}\hat{G}(\mathbf{x}_{n-1}\to\mathbf{x}_{n})\hat{f}(\mathbf{x}_{n-1}\to\mathbf{x}_{n}\to\mathbf{x}_{n+1})\bigg]\hat{G}(\mathbf{x}_{N-1}\to\mathbf{x}_{N})W_e^{(j)}(\mathbf{x}_{N-1}\to\mathbf{x}_{N})
\end{align}
\]</span></p>
<p>A lot of the notation here is pretty standard and the hats (<span class="math inline">\(\hat{\cdot}\)</span>) just represents the emission function <span class="math inline">\(L_e\)</span>, scattering function <span class="math inline">\(f\)</span>, and geometry function <span class="math inline">\(G\)</span> are their generalized counterpart of surface-only transport. They are evaluated slightly differently when interacting with volumetric points.</p>
<p>A <em>single sample</em> of Monte-Carlo evaluation of the measurement integral:</p>
<p><span class="math display">\[
I_j = \frac{\hat{L_e}(\mathbf{x}_{1}\to\mathbf{x}_{2})\bigg[\prod^{N-1}_{n=2}\hat{G}(\mathbf{x}_{n-1}\to\mathbf{x}_{n})\hat{f}(\mathbf{x}_{n-1}\to\mathbf{x}_{n}\to\mathbf{x}_{n+1})\bigg]\hat{G}(\mathbf{x}_{N-1}\to\mathbf{x}_{N})W_e^{(j)}(\mathbf{x}_{N-1}\to\mathbf{x}_{N})}{\text{pdf}(\overline{\mathbf{x}})}
\]</span></p>
<p>Recall that for each path, we uniformly branch between surface scattering and volumetric scattering, which be simplified away (we implicitly included a factor of <span class="math inline">\(2\)</span> in the previous equations). However, this means the PDF at each vertices depends on the branching. Additional, if <span class="math inline">\(\mathbf{x}_p=\mathbf{x}_N\)</span>, the sensor is a surface (i.e., we usually render on a flat rectangular screen), and we pre-determine the light ray per pixel to ensure each pixels is sampled, we also assume <span class="math inline">\(\mathbf{x}_{N-1}\)</span> is given (i.e., not sampled). We also assume <span class="math inline">\(\hat{L_e}\)</span> is an area light source on a surface (not volumetric), which means we sample it on a surface and its PDF is the inverse of its surface area <span class="math inline">\(\text{pdf}_A(\mathbf{x}_1)\)</span>. This remains us with <span class="math inline">\(\prod_{k=2}^{N-2} \widehat{\text{pdf}}(\mathbf{x}_k)\)</span>.</p>
<p>Importantly, to make the computation of PDF practical and closer to the algorithm than the theory, we use <strong>cosine-weighted BSDF sampling</strong>, simplifying <span class="math inline">\(\hat{G}\)</span> term and the PDF<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> to just the transmittance <span class="math inline">\(T\)</span>. When we branch to volumetric scattering, we will additionally sample the position along a lienar path from <span class="math inline">\(k\)</span>th vertex to the next <em>surface</em> intersection. We have to additionally incorporate its PDF as <span class="math inline">\(\frac{1}{t_k}\)</span> where <span class="math inline">\(t_k\)</span> is the length between the two vertices. We denote <span class="math inline">\(\frac{1}{\hat{t_k}}\)</span> where it will just be <span class="math inline">\(1\)</span> when branched to the surface intersection. For the volumetric scattering, they are full spherical integration, not hemisphere. Additionally, we will be assuming istropic scattering. Therefore, the phase function <span class="math inline">\(p\)</span> would be <span class="math inline">\(p(\mathbf{x},\omega_i\to\omega_o)=\frac{1}{4\pi}\)</span> <a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> and its PDF would be <span class="math inline">\(\frac{1}{4\pi}\)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn20"><p><sup>20</sup>&nbsp;The term, <span class="math inline">\(\hat{G}(\mathbf{x}_{n-1}\to\mathbf{x}_{n})=G(\mathbf{x}_{n-1}\to\mathbf{x}_{n})T(\mathbf{x}_{n-1}\to\mathbf{x}_{n})\)</span>, is an extension of the regular surface-only <span class="math inline">\(G\)</span> term. Since we are directly sampling the ray direction <span class="math inline">\(\omega\)</span>, the <span class="math inline">\(\frac{1}{r^2}\)</span> (or <span class="math inline">\(\frac{1}{(\mathbf{x}-\mathbf{y})^2}\)</span>) factor is omitted. When we further sample the direction directly via cosine-weighting, we can entirely omit the <span class="math inline">\(\cos\)</span> term on either side (recall, <span class="math inline">\(G=\frac{\cos_\mathbf{x}\theta_1 \cos_\mathbf{y}\theta_2}{(\mathbf{x}-\mathbf{y})^2}\)</span>).</p></div><div id="fn21"><p><sup>21</sup>&nbsp;Phase functions are normalized.</p></div></div><p><span class="math display">\[
\widehat{\text{pdf}}(\mathbf{x}_k) := \begin{cases}
\displaystyle \widehat{\text{pdf}}_S(\omega_i;\mathbf{x}_k)=1 &amp; \mathbf{x}_k\in S  \\
\displaystyle \widehat{\text{pdf}}_V(\omega_i;\mathbf{x}_k)=\frac{1}{4\pi} &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>This finally yields us the simplified expression below. <a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn22"><p><sup>22</sup>&nbsp;Monte-Carlo estimation can be really confusing at times (in the context of importance sampling), just like the messy indices in Christoffel symbols or deriving backpropogation for optimizing function approximators. When you change the sampling process, you change the PDF in the <em>single-sample</em> formulation below, but you also <em>implicitly</em> change the factor when you average over the number of <em>overall samples</em>. The factor will reveal itself when working out the math. So, if we do cosine-weighted sampling for the surface scattering, yes the PDF will be <span class="math inline">\(\cos\)</span>, yes it will cancel out the <span class="math inline">\(\cos\)</span> in the numerator, but <span class="math inline">\(\cos\)</span> will re-appear <em>implicitly</em> when you average over samples to ensure unbiasedness. This implictness appears as frequency.</p></div></div><p><span class="math display">\[
I_j = \frac{L_e(\mathbf{x}_{1}\to\mathbf{x}_{2})G^*\bigg[\prod^{N-1}_{n=2}T(\mathbf{x}_{n-1}\to\mathbf{x}_{n})\hat{f}(\mathbf{x}_{n-1}\to\mathbf{x}_{n}\to\mathbf{x}_{n+1})\bigg]T(\mathbf{x}_{N-1}\to\mathbf{x}_{N})W_e^{(j)}(\mathbf{x}_{N-1}\to\mathbf{x}_{N})}{\text{pdf}_A(\mathbf{x}_1)(\prod_{k=3}^{N-2} \widehat{\text{pdf}}(\mathbf{x}_k)\frac{1}{\hat{t_k}})\frac{1}{\hat{t_N}}}
\]</span></p>
<p><span class="math inline">\(G^*\)</span> since we are still doing area sampling on last vertex: the light.</p>
<p>We‚Äôve done it! As for the theory, there‚Äôs not much else to get this most basic version of volumetric path tracing running. Anything that comes after are more like algorithmic and design choices to make the code more optimal and fit nicely with the OptiX frameworks (e.g., closest hit, raygen, and miss hit shaders).</p>
</section>
</section>
<section id="perfect-scattering-of-the-fog" class="level1 page-columns page-full">
<h1>Perfect Scattering of the Fog</h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../img/blog/10_ctrl_f.png" class="img-fluid figure-img"></p>
<figcaption>Did a ctrl+f on ‚Äúassum‚Äù for ‚Äúassumptions‚Äù and ‚Äúassume‚Äù.</figcaption>
</figure>
</div>
<p>This is just the beginning, but coming this far, I‚Äôve realized how in rendering, you really have to know what you are assuming (or taking math classes have made me just be better at realizing this now). Just like in physics, you have to know what system you are working with. In our case, rendering comes in gazillion flavors with various possible modifications and tweaks, and knowing exactly what assumption or model of the rendering process will lead more clearer picture on your implementation and your understanding of the process. Lowkey general machine learning allows you to play around more, allowing more mistakes without devestating results (i.e., more resilient to mistakes), until it‚Äôs too late.<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn23"><p><sup>23</sup>&nbsp;Not like I feel 100% confident that all the derivations and the progression in this blog is exactly correct, but I am doing the best I can.</p></div></div><p>It is amazing to see how all this equations and constructions is possible by assuming four key physical processes: absorption, emission, out-scattering, and in-scattering. With surface scattering and stochasticization of the equations, we get the complete form of a very basic global volumetric rendering.</p>
<section id="algorithmic-view-of-monte-carlo-estimation-of-volumetric-path-integrals" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="algorithmic-view-of-monte-carlo-estimation-of-volumetric-path-integrals">Algorithmic View of Monte-Carlo Estimation of Volumetric Path Integrals</h2>
<div class="callout callout-style-default callout-note no-icon callout-titled" title="Algorithm: Basic Volumetric Path Tracing (Single-Sample) ">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Algorithm: Basic Volumetric Path Tracing (Single-Sample)
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Constants:</strong> Scene geometry surfaces <span class="math inline">\(\mathcal{S}\)</span>, isotrpoic single-scattering albedo <span class="math inline">\(\rho(\mathbf{x},\omega)\)</span>, isotropic absorption coefficient <span class="math inline">\(\sigma_a(\mathbf{x})\)</span>, Russian Roulette <span class="math inline">\(q\)</span>, camera normal/direction <span class="math inline">\(\mathbf{n}\)</span><br>
<strong>Input:</strong> Sensor position <span class="math inline">\(\mathbf{x}_p:=\mathbf{x}_N\)</span>, pre-determined initial incident direction <span class="math inline">\(\omega_i^{(1)}:=\mathbf{x}_{N-1}\to\mathbf{x}_{N}\)</span><br>
<strong>Output:</strong> Outgoing radiance <span class="math inline">\(L_o\)</span> (linear space)</p>
<ol type="1">
<li><span class="math inline">\(\sigma_s(\mathbf{x})=\frac{\rho(\mathbf{x})}{1-\rho(\mathbf{x})}\sigma_a(\mathbf{x})\)</span> // obtained by some algebra</li>
<li><span class="math inline">\(\sigma_t(\mathbf{x}) \triangleq \sigma_a(\mathbf{x})+\sigma_s(\mathbf{x})\)</span></li>
<li><span class="math inline">\(L_o = 0\)</span></li>
<li><span class="math inline">\(\beta = |\omega_i^{(1)}\cdot\mathbf{n}|\)</span> // path throughput (supports NEE) and sensor importance <a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a></li>
<li><span class="math inline">\(\mathbf{x} = \mathbf{x}_p\)</span></li>
<li><span class="math inline">\(\omega_i = \omega_i^{(1)}\)</span></li>
<li><strong>while</strong> True:
<ol type="1">
<li><span class="math inline">\(\mathbf{y},\mathbf{n}_\mathbf{y} \sim \text{lightSurface}\)</span></li>
<li><strong>if</strong> depth is <span class="math inline">\(0\)</span>: // direct lighting
<ol type="1">
<li><strong>if</strong> <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{x}\)</span> are mutually visible:
<ol type="1">
<li><span class="math inline">\(L_o \mathrel{+}= L_ee^{-\sigma_t||\mathbf{y}-\mathbf{x}||}\)</span></li>
</ol></li>
</ol></li>
<li><span class="math inline">\(t=\text{rayTriangleIntersectionTest}(\mathbf{x},-\omega_i)\)</span></li>
<li><span class="math inline">\(u_q \sim U[0,1)\)</span></li>
<li><strong>if</strong> <span class="math inline">\(u_q \geq q\)</span>: // Russian roulette
<ol type="1">
<li><strong>break</strong></li>
</ol></li>
<li><span class="math inline">\(\beta \mathrel{/}= q\)</span></li>
<li><span class="math inline">\(u \sim U[0,1)\)</span></li>
<li><strong>if</strong> <span class="math inline">\(u &lt; 0.5\)</span>: // do surface scattering
<ol type="1">
<li><strong>if</strong> <span class="math inline">\(t\)</span> is undefined: // ray miss
<ol start="2" type="1">
<li><strong>break</strong> // there‚Äôs no <span class="math inline">\(L_\text{miss}\)</span> in volumetric light transport <a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a></li>
</ol></li>
<li><span class="math inline">\(\mathbf{x}'=\mathbf{x}-\omega_i t\)</span></li>
<li><span class="math inline">\(\omega_i \sim \text{cosWeightedBRDF}\)</span></li>
<li><span class="math inline">\(\beta \mathrel{*}= \frac{\rho}{\pi}\)</span> // we assume Lambertian diffuse BSDF for now</li>
<li><span class="math inline">\(\beta \mathrel{*}= e^{-\sigma_tt}\)</span> // we assume homogenous medium for now<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a></li>
</ol></li>
<li><strong>else</strong>: // do volumetric scattering
<ol type="1">
<li><strong>if</strong> <span class="math inline">\(t\)</span> is undefined:
<ol type="1">
<li><span class="math inline">\(d \sim \text{Exp}(\sigma_t)\)</span> // ray miss</li>
<li><span class="math inline">\(\beta \mathrel{*}= \frac{1}{\sigma_t}\)</span> // PDF still has an extra factor</li>
</ol></li>
<li><strong>else</strong>:
<ol type="1">
<li><span class="math inline">\(d \sim \text{U}[0,t)\)</span><br>
</li>
<li><span class="math inline">\(\beta \mathrel{*}= te^{-\sigma_td}\)</span></li>
</ol></li>
<li><span class="math inline">\(\mathbf{x}'=\mathbf{x}-\omega_i d\)</span></li>
<li><span class="math inline">\(\omega_i \sim \text{sphericalPhase}\)</span></li>
<li><span class="math inline">\(\beta \mathrel{*}= \sigma_s\)</span> // where the actual color scattering occur</li>
<li><span class="math inline">\(\beta \mathrel{*}= 1\)</span> // <span class="math inline">\(\frac{\frac{1}{4\pi}}{\frac{1}{4\pi}}\)</span> by uniform sampling over spherical domain <!-- 6.  $\beta \mathrel{*}= e^{-\sigma_td} \cdot t$  // transmittance times PDF correction --></li>
</ol></li>
<li><strong>if</strong> <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{x}'\)</span> are mutually visible:
<ol type="1">
<li><span class="math inline">\(G^*=\frac{|\mathbf{n}_\mathbf{y}\cdot (\mathbf{x}'-\mathbf{y})|}{(\mathbf{x}'-\mathbf{y})^2} e^{-\sigma_t||\mathbf{y}-\mathbf{x}'||}\)</span> // geometry term with transmittance</li>
<li><span class="math inline">\(L_o \mathrel{+}= \beta G^* L_e \frac{1}{A}\)</span></li>
</ol></li>
<li><span class="math inline">\(\mathbf{x}=\mathbf{x}'\)</span></li>
</ol></li>
<li><strong>return</strong> <span class="math inline">\(L_o\)</span></li>
</ol>
</div>
</div>
<div class="no-row-height column-margin column-container"><div id="fn26"><p><sup>26</sup>&nbsp;Homogenous medium allows us to evaluate transmittance with tractable integral, allow us to analytically integrate the formulation to that.</p></div></div><div class="no-row-height column-margin column-container"><div id="fn25"><p><sup>25</sup>&nbsp;Despite us wanting to emulate foggy, it‚Äôs not like a hazy day or a foggy day where there‚Äôs a sun behind a thick layer of scattering, but think of it as foggy in the nighttime without moonlight or stars (i.e., it‚Äôs just goign to be pitch black).</p></div></div><div class="no-row-height column-margin column-container"><div id="fn24"><p><sup>24</sup>&nbsp;The sensor importance that corresponds to the physical process of vignetting. There‚Äôs an additional factor of <span class="math inline">\(\frac{1}{z^2}\)</span> where <span class="math inline">\(z\)</span> is the normal distance between the pinhole aperature and the sensor surface/window (i.e., depth). Since majority of the cases <span class="math inline">\(z=1\)</span>, we can ignore it and leave just the <span class="math inline">\(\cos\)</span> term.</p></div></div><p>I think I know how to live in harmony with AI coding tools now. Writing the algorithm to actually learn what you are doing without the slowdown of fixing errors, bugs, and dealing with syntax. Now, I can finally play around the coefficients in peace and have fun. (There‚Äôs not much to play around with this basic model.) As you play around more, you would realize the the ‚Äúgod‚Äù rays are very noise (i.e., high variance). There must be a better way and I hope I can improve it later down the line. For now, there‚Äôs other aspect of volumetric rendering I want to explore (i.e., inhomogenous medium and fluid simulation).</p>
</section>
<section id="visual-results" class="level2">
<h2 class="anchored" data-anchor-id="visual-results">Visual Results!</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../img/blog/10_frame_046.png" class="img-fluid figure-img"></p>
<figcaption>A slant view with a green single-scattering phase albedo and a lower absorption coefficient.</figcaption>
</figure>
</div>
<p>Note: When I originally render the medium, it was pitch black. Due to how everything is ‚Äúfar apart‚Äù in my scene (i.e., on a order of 100s), the range of coefficients is much different. In fact, it has to be on a level of thousandths or ten-thousandths, and somewhat sensitive to changes in the coefficient. Just something to be aware.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../img/blog/10_frame_038.png" class="img-fluid figure-img"></p>
<figcaption>Spooky Cornell box (higher absorption).</figcaption>
</figure>
</div>
<!-- [^xy]: $\forall x,\sigma_s \leq \sigma_t$ -->
<p>Source code: <a href="https://github.com/andrew-shc/vpt">https://github.com/andrew-shc/vpt</a>.</p>


<script type="ojs-module-contents">
eyJjb250ZW50cyI6W119
</script>
<div id="exercise-loading-indicator" class="exercise-loading-indicator d-none d-flex align-items-center gap-2">
<div id="exercise-loading-status" class="d-flex gap-2">

</div>
<div class="spinner-grow spinner-grow-sm">

</div>
</div>
<script type="vfs-file">
W10=
</script>
<script type="ojs-module-contents">
eyJjb250ZW50cyI6W119
</script>
<div id="exercise-loading-indicator" class="exercise-loading-indicator d-none d-flex align-items-center gap-2">
<div id="exercise-loading-status" class="d-flex gap-2">

</div>
<div class="spinner-grow spinner-grow-sm">

</div>
</div>
<script type="vfs-file">
W10=
</script>

</section>
</section>


</main> <!-- /main -->
<script type="ojs-module-contents">
eyJjb250ZW50cyI6W119
</script>
<script type="module">
if (window.location.protocol === "file:") { alert("The OJS runtime does not work with file:// URLs. Please use a web server to view this document."); }
window._ojs.paths.runtimeToDoc = "../../blog";
window._ojs.paths.runtimeToRoot = "../..";
window._ojs.paths.docToRoot = "..";
window._ojs.selfContained = false;
window._ojs.runtime.interpretFromScriptTags();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark_dimmed">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      if (authorPrefersDark) {
          [baseTheme, altTheme] = [altTheme, baseTheme];
      }
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "andrew-shc/andrew-shc.github.io";
    script.dataset.repoId = "R_kgDOMDq5Jg";
    script.dataset.category = "Announcements";
    script.dataset.categoryId = "DIC_kwDOMDq5Js4C2fss";
    script.dataset.mapping = "pathname";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "bottom";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->




</body></html>